\documentclass[12pt]{rapport}
\usetikzlibrary{%
  calc,%
  decorations.pathmorphing,%
  fadings,%
  shadings%
}
\usepackage{physics}
\usepackage{fixltx2e}
\usepackage{textcomp}
\course{34319: Programming Projects in IT and Communication Technology}

\title{Voix-er: VoIP/IM application}
\author{
  Martin Madsen (s124320)\\
  Christian Laustsen (s124324)
}
\date{28. Juni 2013}

\begin{document}
\maketitle

\section*{Introduction}
The program features a server and a client. It supports basic IM with
personal messaging and chat rooms that allow several users to interact
with each other in real time. Furthermore, the application also
implements VoIP (voice over IP), which allows the users to talk
directly to one another.\newline


The server-side part of the application is mainly written by Christian
(s124324), and the client-side of the application is mainly written by
Martin (s124320), although some sparring has been going on, as is
natural.


\section*{Requirements}
The following is a list of requirements that were specified for the
program when the project started. Some have been dumped or had failed
attempts of implementation.

\subsection*{Implemented}
\begin{itemize}
  \item A server that will allow multiple clients to connect
  \item A way to keep track of connected clients and their information
    (nicknames etc)
  \item Support for IM in the application
  \item A protocol for establishing a connection with the server and
    for the IM part of the application
  \item Chat rooms where several people can chat together at the same
    time
  \item A default channel where people are put when they connect
\end{itemize}

\subsection*{Not implemented}
\begin{itemize}
  \item Group VoIP chat
\end{itemize}


\section*{Design \& Implementation}
The server-side of the application is divided into several files which
each hold their own class. Each class is called the same as its file
(ie. channel.py holds the class Channel, and talk\_action.py holds the
class TalkAction).

\subsection*{tcp\_server.py}
The TCPServer class is the main class of the server. It keeps track of
connected clients and when they are ready to be read from or written
to. It also provides an easy access to queue messages on the client
objects. The Server class is also responsible for PINGing the clients
periodically. The server class is the one the instantiates new Client
objects.

\subsection*{tcp\_client.py}
The TCPClient class takes care of the TCP connected clients (usually
IM, and also used to initiate the UDP client). It keeps track of when
it was pinged, its own User object, the message queue for the
socket/client etc. The TCPClient is also the one that instantiates new
Channel objects when needed (or reuses them if the channel already
exists).

\subsection*{parser.py}
The Parser class handles the underlying protocol. It manages joins,
pings, messages, connections, disconnections etc. It interacts with
the Server and the Client/User object. Lastly, the Parser is also
responsible for instantiating new Talk objects in new threads when
necessary (and uses TalkAction objects to handle actions related to
the talk protocol).

\subsection*{channel.py}
The Channel class gathers information about the channel, and what
users are in it, along with giving quick methods for etc cleaning up a
channel. The channel object holds a static dictionary (hashmap) of all
the channel names pointing to their channel objects. This provides an
easy way to avoid channel name duplication.

\subsection*{user.py}
The User class holds the user data, and provides easy access to
leaving or joining a channel. The User class holds a static list of
all user nicknames (represented in strings), which allows the server
to quickly determine if the nickname is already is in use.

\subsection*{talk.py}
The Talk class takes care of the VoIP chat sessions, and manages the
UDP clients that are connected/linked to it. It has a session key, to
provide a quick way of referencing what Talk object (what
conversation) the client needs to enter. It waits for a TalkAction
object to perform some action (if it doesn't get one it 30 seconds, it
closes since the connection is seen as dead).

\subsection*{talk\_action.py}
The TalkAction class simply holds the action and the target of said
action, that is used in the Talk object.


\section*{Protocol}
For the application, a custom protocol has been made. The following is
a list with an explanation of all the protocol commands/actions.

\subsection*{CONNECT}
From    - Client\newline
Syntax  - CONNECT: $<$nickname$>$ $<$realname$>$ version number\newline
Example - CONNECT: "John87" "John Wilson" 1.0.0\newline

\noindent The CONNECT action is sent when the client makes the initial
connection. Without this, the client cannot proceed further since all
commands will be seen as invalid if the user hasn't authenticated
himself with this.

\subsection*{ACCEPT}
From    - Server\newline
Syntax  - ACCEPT: $<$hostname$>$\newline
Example - ACCEPT: ip.google.com\newline

\noindent The ACCEPT action is sent to the client to acknowledge the
CONNECT.

\subsection*{NOTACCEPTED}
From    - Server\newline
Syntax  - NOTACCEPTED: $<$message$>$\newline
Example - NOTACCEPTED: Syntax error, please resend the CONNECT request\newline

\noindent The NOTACCEPTED action is sent when either there is a syntax
error in the CONNECT, or when the CONNECT hasn't been sent.

\subsection*{NICKNAMEINUSE}
From    - Server\newline
Syntax  - NICKNAMEINUSE: $<$message$>$\newline
Example - NICKNAMEINUSE: The nickname 'John83' is already taken\newline

\noindent The NICKNAMEINUSE action is sent when the nickname that the
user sent in with the CONNECT is already in use.

\subsection*{PING}
From    - Server\newline
Syntax  - PING: $<$random number$>$\newline
Example - PING: 42313812731\newline

\noindent The server keeps track of if clients are still connected by
sending them a PING periodically, and expecting a return PONG from
them with the same number as the PING had.

\subsection*{PONG}
From    - Client\newline
Syntax  - PONG: $<$random number recieved from PING$>$\newline
Example - PONG: 42313812731\newline

\noindent The client sends a PONG as a response to a PING to let the
server know that it is actually connected, and isn't a faulty
connection (or that it has a latency higher than a set amount of
seconds, which is 150 by default).

\subsection*{JOIN}
From    - Client\newline
Syntax  - JOIN: $<$channel$>$\newline
Example - JOIN: \#SuperAwesomeChannel\newline

\noindent Send a request to the server to join a channel.

\subsection*{JOINED}
From    - Server\newline
Syntax  - JOINED: $<$channel$>$\newline
Example - JOINED: \#SuperAwesomeChannel\newline

\noindent Respond to the client that it has successfully joined a channel.

\subsection*{USERLIST}
From    - Server\newline
Syntax  - USERLIST $<$channel$>$: $<$comma separated list of users$>$\newline
Example - USERLIST \#SuperAwesomeChannel: Will, John83, Mike\newline

\noindent This is send right after the JOINED action, and lists all
the users in the channel including the user itself (the client is
responsible for filtering this out).

\subsection*{USERJOIN}
From    - Server\newline
Syntax  - USERJOIN $<$channel$>$: $<$nickname$>$\newline
Example - USERJOIN \#SuperAwesomeChannel: Thomas12\newline

\noindent Notify the client that a user has joined a channel.

\subsection*{USERLEAVE}
From    - Server\newline
Syntax  - USERLEAVE $<$channel$>$: $<$nickname$>$\newline
Example - USERLEAVE \#SuperAwesomeChannel: Thomas12\newline

\noindent Notify the client that a user has left a channel.

\subsection*{MSG}
From    - Client\newline
Syntax  - MSG $<$recipient$>$: $<$message$>$\newline
Example - MSG \#SuperAwesomeChannel: Hey all! How's it going?\newline
Example - MSG John83: Hey John! How's it going?\newline

\noindent The client can either send a message to a channel (where all
clients in that channel receives it), or directly to a user.

\subsection*{MSG}
From    - Server\newline
Syntax  - MSG $<$sender$>$ $<$recipient$>$: $<$message$>$\newline
Example - MSG Thomas12 \#SuperAwesomeChannel: Hey all! How's it going?\newline
Example - MSG Thomas12 John83: Hey John! How's it going?\newline

\noindent The server notifies either all the clients in a channel, or
just one client directly, that a message has been sent to them and
where the message stems from.

\subsection*{TALK (REQUEST)}
From    - Client\newline
Syntax  - TALK $<$nickname$>$: REQUEST\newline
Example - TALK John83: REQUEST\newline

\noindent Request a VoIP conversation with John83.

\subsection*{TALK (REQUEST)}
From    - Server\newline
Syntax  - TALK $<$nickname$>$ $<$session key$>$: REQUEST\newline
Example - TALK John83 827742843590392: REQUEST\newline
Example - TALK Mike 827742843590392: REQUEST\newline

\noindent The one that requested the conversation (let's say John83
did this) recieves this messages with the nickname being the one he
requested. He then needs to store the session key for later use in the
conversation.\newline
\noindent The one that recieves the request (which will be Mike in
this case) will get the nickname of the requester in place of
nickname. The reciever will also need to store the session key, for
when he answers back.

\subsection*{TALK (ACCEPT/DENY)}
From    - Client\newline
Syntax  - TALK $<$nickname$>$ $<$session key$>$: ACCEPT\newline
Syntax  - TALK $<$nickname$>$ $<$session key$>$: DENY\newline
Example - TALK John83 827742843590392: ACCEPT\newline
Example - TALK John83 827742843590392: DENY\newline

\noindent To continue the example from before, the one that got the
request (Mike), will either accept or deny the request, and will send
the matching action to the server.

\subsection*{TALK (ACCEPTED/DENIED)}
From    - Client\newline
Syntax  - TALK $<$nickname$>$ $<$session key$>$: ACCEPTED\newline
Syntax  - TALK $<$nickname$>$ $<$session key$>$: DENIED\newline
Example - TALK Mike 827742843590392: ACCEPTED\newline
Example - TALK Mike 827742843590392: DENIED\newline

\noindent Again, continuing the example, since the one that got the
reqeust (Mike) has now answered with either a ACCEPT or DENY, the
requester (John83) will now get a response from the server stating
whether or not the request got accepted. If the conversation is
accepted, the VoIP conversation is started, if it's denied, the
process is stopped.

\subsection*{TALKSESSION}
From    - Client\newline
Syntax  - TALKSESSION: $<$session key$>$\newline
Example - TALKSESSION: 827742843590392\newline

\noindent This is sent by the UDP client after a talk request has been
accepted. It initiates the talk session/conversation.

\subsection*{SESSIONERROR}
From    - Server\newline
Syntax  - SESSIONERROR: $<$message$>$\newline
Example - SESSIONERROR: Invalid session key '827742843590392'\newline

\noindent If the TALKSESSION sends a wrong (nonexistant) or invalid
session key, the server responds with a SESSIONERROR.

\subsection*{DISCONNECT}
From    - Client\newline
Syntax  - DISCONNECT\newline
Example - DISCONNECT\newline

\noindent Signals to the server that the user is disconnecting, and
allows the server to quickly clean up after the user.

\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.9]{../uml/uml_class_diagram_for_voix_cli}
    \caption{TODO:}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.9]{../uml/uml_class_diagram_for_voix_con}
    \caption{TODO:}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.9]{../uml/uml_class_diagram_for_voix_int}
    \caption{TODO:}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.9]{../uml/uml_class_diagram_for_voix_mes}
    \caption{TODO:}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.9]{../uml/uml_class_diagram_for_voix_par}
    \caption{TODO:}
  \end{center}
\end{figure}
\section*{Testing}
The client has a variety of tests to assure valid data while
developing. The client is tested by itself with a dummy server. The
dummy server is to make sure data sent from the client reaches the
server it is connected to. This does mean, that not all scenarios are
testable and therefore communication between the client and the real
server may cause unexpected results. In this situation the scenarios
are only testable by black-box testing.

The client code is approximately covered $91\%$. This coverage is
distributed on modules as seen in the following scheme.

\begin{verbatim}
  Name                   Stmts   Miss  Cover   Missing
  ----------------------------------------------------
  voix                       0      0   100%
  voix.client              101      7    93%   109, 148, 206, 217-218, 221-222
  voix.connection           68      4    94%   103, 107-110
  voix.interface             0      0   100%
  voix.interface.cli        68      9    87%   38, 92, 104, 117-118, 126-129
  voix.interface.gui         6      3    50%   17-19
  voix.message_handler       8      0   100%
  voix.parser               14      0   100%
  ----------------------------------------------------
  TOTAL                    265     23    91%
  ----------------------------------------------------------------------
  Ran 16 tests in 6.187s

  OK
\end{verbatim}

The test methods' names should explain the goal that is wished to
assert for. And the runtime of
{\fontfamily{ptm}\selectfont\texttildelow}$6$ seconds is caused by
delays to overcome threaded operations.

For the server, a fake client is made to overcome the same situation
as on the client. Again real scenarios are not tested and the test
cases may not be reliable.

\section*{Possible features \& expansions}
Here's a list of additional brainstormed features and things that
should be done.
\begin{itemize}
\item Major code cleanup (mainly on the client) and possible
  rewrites of parts of the code that would simplify certain complex
  tasks.
  % TODO: more features??
\end{itemize}


\newpage
\section*{Conclusion}




\newpage
\section*{User guide}

\end{document}